package discord.gamesdk;// Generated by jextract

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.util.function.*;

import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct IDiscordOverlayManager {
 *     void (*is_enabled)(struct IDiscordOverlayManager *, bool *);
 *     void (*is_locked)(struct IDiscordOverlayManager *, bool *);
 *     void (*set_locked)(struct IDiscordOverlayManager *, bool, void *, void (*)(void *, enum EDiscordResult));
 *     void (*open_activity_invite)(struct IDiscordOverlayManager *, enum EDiscordActivityActionType, void *, void (*)(void *, enum EDiscordResult));
 *     void (*open_guild_invite)(struct IDiscordOverlayManager *, const char *, void *, void (*)(void *, enum EDiscordResult));
 *     void (*open_voice_settings)(struct IDiscordOverlayManager *, void *, void (*)(void *, enum EDiscordResult));
 *     enum EDiscordResult (*init_drawing_dxgi)(struct IDiscordOverlayManager *, IDXGISwapChain *, bool);
 *     void (*on_present)(struct IDiscordOverlayManager *);
 *     void (*forward_message)(struct IDiscordOverlayManager *, MSG *);
 *     void (*key_event)(struct IDiscordOverlayManager *, bool, const char *, enum EDiscordKeyVariant);
 *     void (*char_event)(struct IDiscordOverlayManager *, const char *);
 *     void (*mouse_button_event)(struct IDiscordOverlayManager *, uint8_t, int32_t, enum EDiscordMouseButton, int32_t, int32_t);
 *     void (*mouse_motion_event)(struct IDiscordOverlayManager *, int32_t, int32_t);
 *     void (*ime_commit_text)(struct IDiscordOverlayManager *, const char *);
 *     void (*ime_set_composition)(struct IDiscordOverlayManager *, const char *, struct DiscordImeUnderline *, uint32_t, int32_t, int32_t);
 *     void (*ime_cancel_composition)(struct IDiscordOverlayManager *);
 *     void (*set_ime_composition_range_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, int32_t, int32_t, struct DiscordRect *, uint32_t));
 *     void (*set_ime_selection_bounds_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, struct DiscordRect, struct DiscordRect, bool));
 *     bool (*is_point_inside_click_zone)(struct IDiscordOverlayManager *, int32_t, int32_t);
 * }
 * }
 */
public class IDiscordOverlayManager {

    IDiscordOverlayManager() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        discord_game_sdk_h.C_POINTER.withName("is_enabled"),
        discord_game_sdk_h.C_POINTER.withName("is_locked"),
        discord_game_sdk_h.C_POINTER.withName("set_locked"),
        discord_game_sdk_h.C_POINTER.withName("open_activity_invite"),
        discord_game_sdk_h.C_POINTER.withName("open_guild_invite"),
        discord_game_sdk_h.C_POINTER.withName("open_voice_settings"),
        discord_game_sdk_h.C_POINTER.withName("init_drawing_dxgi"),
        discord_game_sdk_h.C_POINTER.withName("on_present"),
        discord_game_sdk_h.C_POINTER.withName("forward_message"),
        discord_game_sdk_h.C_POINTER.withName("key_event"),
        discord_game_sdk_h.C_POINTER.withName("char_event"),
        discord_game_sdk_h.C_POINTER.withName("mouse_button_event"),
        discord_game_sdk_h.C_POINTER.withName("mouse_motion_event"),
        discord_game_sdk_h.C_POINTER.withName("ime_commit_text"),
        discord_game_sdk_h.C_POINTER.withName("ime_set_composition"),
        discord_game_sdk_h.C_POINTER.withName("ime_cancel_composition"),
        discord_game_sdk_h.C_POINTER.withName("set_ime_composition_range_callback"),
        discord_game_sdk_h.C_POINTER.withName("set_ime_selection_bounds_callback"),
        discord_game_sdk_h.C_POINTER.withName("is_point_inside_click_zone")
    ).withName("IDiscordOverlayManager");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * void (*is_enabled)(struct IDiscordOverlayManager *, bool *)
     * }
     */
    public static class is_enabled {

        is_enabled() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout is_enabled$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("is_enabled"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*is_enabled)(struct IDiscordOverlayManager *, bool *)
     * }
     */
    public static final AddressLayout is_enabled$layout() {
        return is_enabled$LAYOUT;
    }

    private static final long is_enabled$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*is_enabled)(struct IDiscordOverlayManager *, bool *)
     * }
     */
    public static final long is_enabled$offset() {
        return is_enabled$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*is_enabled)(struct IDiscordOverlayManager *, bool *)
     * }
     */
    public static MemorySegment is_enabled(MemorySegment struct) {
        return struct.get(is_enabled$LAYOUT, is_enabled$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*is_enabled)(struct IDiscordOverlayManager *, bool *)
     * }
     */
    public static void is_enabled(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(is_enabled$LAYOUT, is_enabled$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*is_locked)(struct IDiscordOverlayManager *, bool *)
     * }
     */
    public static class is_locked {

        is_locked() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout is_locked$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("is_locked"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*is_locked)(struct IDiscordOverlayManager *, bool *)
     * }
     */
    public static final AddressLayout is_locked$layout() {
        return is_locked$LAYOUT;
    }

    private static final long is_locked$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*is_locked)(struct IDiscordOverlayManager *, bool *)
     * }
     */
    public static final long is_locked$offset() {
        return is_locked$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*is_locked)(struct IDiscordOverlayManager *, bool *)
     * }
     */
    public static MemorySegment is_locked(MemorySegment struct) {
        return struct.get(is_locked$LAYOUT, is_locked$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*is_locked)(struct IDiscordOverlayManager *, bool *)
     * }
     */
    public static void is_locked(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(is_locked$LAYOUT, is_locked$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*set_locked)(struct IDiscordOverlayManager *, bool, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static class set_locked {

        set_locked() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, boolean _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_BOOL,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, boolean _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_locked$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_locked"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*set_locked)(struct IDiscordOverlayManager *, bool, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static final AddressLayout set_locked$layout() {
        return set_locked$LAYOUT;
    }

    private static final long set_locked$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*set_locked)(struct IDiscordOverlayManager *, bool, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static final long set_locked$offset() {
        return set_locked$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*set_locked)(struct IDiscordOverlayManager *, bool, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static MemorySegment set_locked(MemorySegment struct) {
        return struct.get(set_locked$LAYOUT, set_locked$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*set_locked)(struct IDiscordOverlayManager *, bool, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static void set_locked(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_locked$LAYOUT, set_locked$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*open_activity_invite)(struct IDiscordOverlayManager *, enum EDiscordActivityActionType, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static class open_activity_invite {

        open_activity_invite() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_INT,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout open_activity_invite$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("open_activity_invite"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*open_activity_invite)(struct IDiscordOverlayManager *, enum EDiscordActivityActionType, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static final AddressLayout open_activity_invite$layout() {
        return open_activity_invite$LAYOUT;
    }

    private static final long open_activity_invite$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*open_activity_invite)(struct IDiscordOverlayManager *, enum EDiscordActivityActionType, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static final long open_activity_invite$offset() {
        return open_activity_invite$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*open_activity_invite)(struct IDiscordOverlayManager *, enum EDiscordActivityActionType, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static MemorySegment open_activity_invite(MemorySegment struct) {
        return struct.get(open_activity_invite$LAYOUT, open_activity_invite$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*open_activity_invite)(struct IDiscordOverlayManager *, enum EDiscordActivityActionType, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static void open_activity_invite(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(open_activity_invite$LAYOUT, open_activity_invite$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*open_guild_invite)(struct IDiscordOverlayManager *, const char *, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static class open_guild_invite {

        open_guild_invite() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout open_guild_invite$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("open_guild_invite"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*open_guild_invite)(struct IDiscordOverlayManager *, const char *, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static final AddressLayout open_guild_invite$layout() {
        return open_guild_invite$LAYOUT;
    }

    private static final long open_guild_invite$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*open_guild_invite)(struct IDiscordOverlayManager *, const char *, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static final long open_guild_invite$offset() {
        return open_guild_invite$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*open_guild_invite)(struct IDiscordOverlayManager *, const char *, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static MemorySegment open_guild_invite(MemorySegment struct) {
        return struct.get(open_guild_invite$LAYOUT, open_guild_invite$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*open_guild_invite)(struct IDiscordOverlayManager *, const char *, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static void open_guild_invite(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(open_guild_invite$LAYOUT, open_guild_invite$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*open_voice_settings)(struct IDiscordOverlayManager *, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static class open_voice_settings {

        open_voice_settings() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout open_voice_settings$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("open_voice_settings"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*open_voice_settings)(struct IDiscordOverlayManager *, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static final AddressLayout open_voice_settings$layout() {
        return open_voice_settings$LAYOUT;
    }

    private static final long open_voice_settings$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*open_voice_settings)(struct IDiscordOverlayManager *, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static final long open_voice_settings$offset() {
        return open_voice_settings$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*open_voice_settings)(struct IDiscordOverlayManager *, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static MemorySegment open_voice_settings(MemorySegment struct) {
        return struct.get(open_voice_settings$LAYOUT, open_voice_settings$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*open_voice_settings)(struct IDiscordOverlayManager *, void *, void (*)(void *, enum EDiscordResult))
     * }
     */
    public static void open_voice_settings(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(open_voice_settings$LAYOUT, open_voice_settings$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * enum EDiscordResult (*init_drawing_dxgi)(struct IDiscordOverlayManager *, IDXGISwapChain *, bool)
     * }
     */
    public static class init_drawing_dxgi {

        init_drawing_dxgi() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, boolean _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            discord_game_sdk_h.C_INT,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_BOOL
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, boolean _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout init_drawing_dxgi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("init_drawing_dxgi"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum EDiscordResult (*init_drawing_dxgi)(struct IDiscordOverlayManager *, IDXGISwapChain *, bool)
     * }
     */
    public static final AddressLayout init_drawing_dxgi$layout() {
        return init_drawing_dxgi$LAYOUT;
    }

    private static final long init_drawing_dxgi$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum EDiscordResult (*init_drawing_dxgi)(struct IDiscordOverlayManager *, IDXGISwapChain *, bool)
     * }
     */
    public static final long init_drawing_dxgi$offset() {
        return init_drawing_dxgi$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum EDiscordResult (*init_drawing_dxgi)(struct IDiscordOverlayManager *, IDXGISwapChain *, bool)
     * }
     */
    public static MemorySegment init_drawing_dxgi(MemorySegment struct) {
        return struct.get(init_drawing_dxgi$LAYOUT, init_drawing_dxgi$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum EDiscordResult (*init_drawing_dxgi)(struct IDiscordOverlayManager *, IDXGISwapChain *, bool)
     * }
     */
    public static void init_drawing_dxgi(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(init_drawing_dxgi$LAYOUT, init_drawing_dxgi$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*on_present)(struct IDiscordOverlayManager *)
     * }
     */
    public static class on_present {

        on_present() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout on_present$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("on_present"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*on_present)(struct IDiscordOverlayManager *)
     * }
     */
    public static final AddressLayout on_present$layout() {
        return on_present$LAYOUT;
    }

    private static final long on_present$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*on_present)(struct IDiscordOverlayManager *)
     * }
     */
    public static final long on_present$offset() {
        return on_present$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*on_present)(struct IDiscordOverlayManager *)
     * }
     */
    public static MemorySegment on_present(MemorySegment struct) {
        return struct.get(on_present$LAYOUT, on_present$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*on_present)(struct IDiscordOverlayManager *)
     * }
     */
    public static void on_present(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(on_present$LAYOUT, on_present$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*forward_message)(struct IDiscordOverlayManager *, MSG *)
     * }
     */
    public static class forward_message {

        forward_message() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout forward_message$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("forward_message"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*forward_message)(struct IDiscordOverlayManager *, MSG *)
     * }
     */
    public static final AddressLayout forward_message$layout() {
        return forward_message$LAYOUT;
    }

    private static final long forward_message$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*forward_message)(struct IDiscordOverlayManager *, MSG *)
     * }
     */
    public static final long forward_message$offset() {
        return forward_message$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*forward_message)(struct IDiscordOverlayManager *, MSG *)
     * }
     */
    public static MemorySegment forward_message(MemorySegment struct) {
        return struct.get(forward_message$LAYOUT, forward_message$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*forward_message)(struct IDiscordOverlayManager *, MSG *)
     * }
     */
    public static void forward_message(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(forward_message$LAYOUT, forward_message$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*key_event)(struct IDiscordOverlayManager *, bool, const char *, enum EDiscordKeyVariant)
     * }
     */
    public static class key_event {

        key_event() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, boolean _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_BOOL,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, boolean _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout key_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("key_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*key_event)(struct IDiscordOverlayManager *, bool, const char *, enum EDiscordKeyVariant)
     * }
     */
    public static final AddressLayout key_event$layout() {
        return key_event$LAYOUT;
    }

    private static final long key_event$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*key_event)(struct IDiscordOverlayManager *, bool, const char *, enum EDiscordKeyVariant)
     * }
     */
    public static final long key_event$offset() {
        return key_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*key_event)(struct IDiscordOverlayManager *, bool, const char *, enum EDiscordKeyVariant)
     * }
     */
    public static MemorySegment key_event(MemorySegment struct) {
        return struct.get(key_event$LAYOUT, key_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*key_event)(struct IDiscordOverlayManager *, bool, const char *, enum EDiscordKeyVariant)
     * }
     */
    public static void key_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(key_event$LAYOUT, key_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*char_event)(struct IDiscordOverlayManager *, const char *)
     * }
     */
    public static class char_event {

        char_event() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout char_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("char_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*char_event)(struct IDiscordOverlayManager *, const char *)
     * }
     */
    public static final AddressLayout char_event$layout() {
        return char_event$LAYOUT;
    }

    private static final long char_event$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*char_event)(struct IDiscordOverlayManager *, const char *)
     * }
     */
    public static final long char_event$offset() {
        return char_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*char_event)(struct IDiscordOverlayManager *, const char *)
     * }
     */
    public static MemorySegment char_event(MemorySegment struct) {
        return struct.get(char_event$LAYOUT, char_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*char_event)(struct IDiscordOverlayManager *, const char *)
     * }
     */
    public static void char_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(char_event$LAYOUT, char_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*mouse_button_event)(struct IDiscordOverlayManager *, uint8_t, int32_t, enum EDiscordMouseButton, int32_t, int32_t)
     * }
     */
    public static class mouse_button_event {

        mouse_button_event() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, byte _x1, int _x2, int _x3, int _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_CHAR,
            discord_game_sdk_h.C_INT,
            discord_game_sdk_h.C_INT,
            discord_game_sdk_h.C_INT,
            discord_game_sdk_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, byte _x1, int _x2, int _x3, int _x4, int _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mouse_button_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mouse_button_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*mouse_button_event)(struct IDiscordOverlayManager *, uint8_t, int32_t, enum EDiscordMouseButton, int32_t, int32_t)
     * }
     */
    public static final AddressLayout mouse_button_event$layout() {
        return mouse_button_event$LAYOUT;
    }

    private static final long mouse_button_event$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*mouse_button_event)(struct IDiscordOverlayManager *, uint8_t, int32_t, enum EDiscordMouseButton, int32_t, int32_t)
     * }
     */
    public static final long mouse_button_event$offset() {
        return mouse_button_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*mouse_button_event)(struct IDiscordOverlayManager *, uint8_t, int32_t, enum EDiscordMouseButton, int32_t, int32_t)
     * }
     */
    public static MemorySegment mouse_button_event(MemorySegment struct) {
        return struct.get(mouse_button_event$LAYOUT, mouse_button_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*mouse_button_event)(struct IDiscordOverlayManager *, uint8_t, int32_t, enum EDiscordMouseButton, int32_t, int32_t)
     * }
     */
    public static void mouse_button_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mouse_button_event$LAYOUT, mouse_button_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*mouse_motion_event)(struct IDiscordOverlayManager *, int32_t, int32_t)
     * }
     */
    public static class mouse_motion_event {

        mouse_motion_event() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_INT,
            discord_game_sdk_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mouse_motion_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mouse_motion_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*mouse_motion_event)(struct IDiscordOverlayManager *, int32_t, int32_t)
     * }
     */
    public static final AddressLayout mouse_motion_event$layout() {
        return mouse_motion_event$LAYOUT;
    }

    private static final long mouse_motion_event$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*mouse_motion_event)(struct IDiscordOverlayManager *, int32_t, int32_t)
     * }
     */
    public static final long mouse_motion_event$offset() {
        return mouse_motion_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*mouse_motion_event)(struct IDiscordOverlayManager *, int32_t, int32_t)
     * }
     */
    public static MemorySegment mouse_motion_event(MemorySegment struct) {
        return struct.get(mouse_motion_event$LAYOUT, mouse_motion_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*mouse_motion_event)(struct IDiscordOverlayManager *, int32_t, int32_t)
     * }
     */
    public static void mouse_motion_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mouse_motion_event$LAYOUT, mouse_motion_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ime_commit_text)(struct IDiscordOverlayManager *, const char *)
     * }
     */
    public static class ime_commit_text {

        ime_commit_text() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ime_commit_text$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ime_commit_text"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ime_commit_text)(struct IDiscordOverlayManager *, const char *)
     * }
     */
    public static final AddressLayout ime_commit_text$layout() {
        return ime_commit_text$LAYOUT;
    }

    private static final long ime_commit_text$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ime_commit_text)(struct IDiscordOverlayManager *, const char *)
     * }
     */
    public static final long ime_commit_text$offset() {
        return ime_commit_text$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ime_commit_text)(struct IDiscordOverlayManager *, const char *)
     * }
     */
    public static MemorySegment ime_commit_text(MemorySegment struct) {
        return struct.get(ime_commit_text$LAYOUT, ime_commit_text$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ime_commit_text)(struct IDiscordOverlayManager *, const char *)
     * }
     */
    public static void ime_commit_text(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ime_commit_text$LAYOUT, ime_commit_text$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ime_set_composition)(struct IDiscordOverlayManager *, const char *, struct DiscordImeUnderline *, uint32_t, int32_t, int32_t)
     * }
     */
    public static class ime_set_composition {

        ime_set_composition() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_INT,
            discord_game_sdk_h.C_INT,
            discord_game_sdk_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ime_set_composition$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ime_set_composition"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ime_set_composition)(struct IDiscordOverlayManager *, const char *, struct DiscordImeUnderline *, uint32_t, int32_t, int32_t)
     * }
     */
    public static final AddressLayout ime_set_composition$layout() {
        return ime_set_composition$LAYOUT;
    }

    private static final long ime_set_composition$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ime_set_composition)(struct IDiscordOverlayManager *, const char *, struct DiscordImeUnderline *, uint32_t, int32_t, int32_t)
     * }
     */
    public static final long ime_set_composition$offset() {
        return ime_set_composition$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ime_set_composition)(struct IDiscordOverlayManager *, const char *, struct DiscordImeUnderline *, uint32_t, int32_t, int32_t)
     * }
     */
    public static MemorySegment ime_set_composition(MemorySegment struct) {
        return struct.get(ime_set_composition$LAYOUT, ime_set_composition$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ime_set_composition)(struct IDiscordOverlayManager *, const char *, struct DiscordImeUnderline *, uint32_t, int32_t, int32_t)
     * }
     */
    public static void ime_set_composition(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ime_set_composition$LAYOUT, ime_set_composition$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ime_cancel_composition)(struct IDiscordOverlayManager *)
     * }
     */
    public static class ime_cancel_composition {

        ime_cancel_composition() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ime_cancel_composition$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ime_cancel_composition"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ime_cancel_composition)(struct IDiscordOverlayManager *)
     * }
     */
    public static final AddressLayout ime_cancel_composition$layout() {
        return ime_cancel_composition$LAYOUT;
    }

    private static final long ime_cancel_composition$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ime_cancel_composition)(struct IDiscordOverlayManager *)
     * }
     */
    public static final long ime_cancel_composition$offset() {
        return ime_cancel_composition$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ime_cancel_composition)(struct IDiscordOverlayManager *)
     * }
     */
    public static MemorySegment ime_cancel_composition(MemorySegment struct) {
        return struct.get(ime_cancel_composition$LAYOUT, ime_cancel_composition$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ime_cancel_composition)(struct IDiscordOverlayManager *)
     * }
     */
    public static void ime_cancel_composition(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ime_cancel_composition$LAYOUT, ime_cancel_composition$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*set_ime_composition_range_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, int32_t, int32_t, struct DiscordRect *, uint32_t))
     * }
     */
    public static class set_ime_composition_range_callback {

        set_ime_composition_range_callback() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_ime_composition_range_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_ime_composition_range_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*set_ime_composition_range_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, int32_t, int32_t, struct DiscordRect *, uint32_t))
     * }
     */
    public static final AddressLayout set_ime_composition_range_callback$layout() {
        return set_ime_composition_range_callback$LAYOUT;
    }

    private static final long set_ime_composition_range_callback$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*set_ime_composition_range_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, int32_t, int32_t, struct DiscordRect *, uint32_t))
     * }
     */
    public static final long set_ime_composition_range_callback$offset() {
        return set_ime_composition_range_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*set_ime_composition_range_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, int32_t, int32_t, struct DiscordRect *, uint32_t))
     * }
     */
    public static MemorySegment set_ime_composition_range_callback(MemorySegment struct) {
        return struct.get(set_ime_composition_range_callback$LAYOUT, set_ime_composition_range_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*set_ime_composition_range_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, int32_t, int32_t, struct DiscordRect *, uint32_t))
     * }
     */
    public static void set_ime_composition_range_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_ime_composition_range_callback$LAYOUT, set_ime_composition_range_callback$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*set_ime_selection_bounds_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, struct DiscordRect, struct DiscordRect, bool))
     * }
     */
    public static class set_ime_selection_bounds_callback {

        set_ime_selection_bounds_callback() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_ime_selection_bounds_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_ime_selection_bounds_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*set_ime_selection_bounds_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, struct DiscordRect, struct DiscordRect, bool))
     * }
     */
    public static final AddressLayout set_ime_selection_bounds_callback$layout() {
        return set_ime_selection_bounds_callback$LAYOUT;
    }

    private static final long set_ime_selection_bounds_callback$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*set_ime_selection_bounds_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, struct DiscordRect, struct DiscordRect, bool))
     * }
     */
    public static final long set_ime_selection_bounds_callback$offset() {
        return set_ime_selection_bounds_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*set_ime_selection_bounds_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, struct DiscordRect, struct DiscordRect, bool))
     * }
     */
    public static MemorySegment set_ime_selection_bounds_callback(MemorySegment struct) {
        return struct.get(set_ime_selection_bounds_callback$LAYOUT, set_ime_selection_bounds_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*set_ime_selection_bounds_callback)(struct IDiscordOverlayManager *, void *, void (*)(void *, struct DiscordRect, struct DiscordRect, bool))
     * }
     */
    public static void set_ime_selection_bounds_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_ime_selection_bounds_callback$LAYOUT, set_ime_selection_bounds_callback$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * bool (*is_point_inside_click_zone)(struct IDiscordOverlayManager *, int32_t, int32_t)
     * }
     */
    public static class is_point_inside_click_zone {

        is_point_inside_click_zone() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            boolean apply(MemorySegment _x0, int _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            discord_game_sdk_h.C_BOOL,
            discord_game_sdk_h.C_POINTER,
            discord_game_sdk_h.C_INT,
            discord_game_sdk_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = discord_game_sdk_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static boolean invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2) {
            try {
                return (boolean) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout is_point_inside_click_zone$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("is_point_inside_click_zone"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool (*is_point_inside_click_zone)(struct IDiscordOverlayManager *, int32_t, int32_t)
     * }
     */
    public static final AddressLayout is_point_inside_click_zone$layout() {
        return is_point_inside_click_zone$LAYOUT;
    }

    private static final long is_point_inside_click_zone$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool (*is_point_inside_click_zone)(struct IDiscordOverlayManager *, int32_t, int32_t)
     * }
     */
    public static final long is_point_inside_click_zone$offset() {
        return is_point_inside_click_zone$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool (*is_point_inside_click_zone)(struct IDiscordOverlayManager *, int32_t, int32_t)
     * }
     */
    public static MemorySegment is_point_inside_click_zone(MemorySegment struct) {
        return struct.get(is_point_inside_click_zone$LAYOUT, is_point_inside_click_zone$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool (*is_point_inside_click_zone)(struct IDiscordOverlayManager *, int32_t, int32_t)
     * }
     */
    public static void is_point_inside_click_zone(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(is_point_inside_click_zone$LAYOUT, is_point_inside_click_zone$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

